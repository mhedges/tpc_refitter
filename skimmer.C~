/******************************************************************************
 * Program: TPC Phase I data skimmer
 * Author: Michael Hedges
 * Purpose: Skim Igal's BASF2 output for relevant data to be stored in BEAST
 * global ntuples for analysis
******************************************************************************/

#define skimmer_cxx
#include "skimmer.h"
#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <iostream>

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <algorithm>
//#include <thread>
#include <iostream>
#include <algorithm>
#include <vector>
#include <sys/time.h>

//#include "constants.h"

//#include "cantProceed.h"
#include "TROOT.h"
#include "TGraph2D.h"
#include "TMath.h"
#include <TVector3.h>
#include <TVirtualFitter.h>

//#include "data_distributor.h"

#define DEBUG 0
#define NROWS 336
#define NCOLS 80
#define NPERFILE 1000
#define ARRSIZE 2400

//TGraph2D *m_gr;
trackInfo *m_track = new trackInfo;   // Single instance of struct that will get overwritten
fitInfo m_fit[NPERFILE];              // NPERFILE instances to be dumped to nTuples
//fitInfo m_fit_copy[NPERFILE];      // Copy of m_fit to pass to writeNtuple thread

float weight[3] = {1., 1., 1.};
int iTPC=0;

void fitTrack(TGraph2D *m_gr) {
  /* Find long aspect of track */
  int x_max_index, y_max_index;
  int x_min_index, y_min_index;
  double *x, *y, *z;
  x = m_gr->GetX(); y = m_gr->GetY(); z = m_gr->GetZ();

  for (int ii=0; ii<m_gr->GetN(); ii++){
	if ( x[ii] == m_gr->GetXmax() )
	  x_max_index = ii;
	else if ( x[ii] == m_gr->GetXmin() )
	  x_min_index = ii;
	if ( y[ii] == m_gr->GetYmax() )
	  y_max_index = ii;
	else if ( x[ii] == m_gr->GetYmin() )
	  y_min_index = ii;
  }

  int p_min_idx = 0, p_max_idx = 0;
  if ( ( m_gr->GetXmax() - m_gr->GetXmin() ) >=
	  ( m_gr->GetYmax() - m_gr->GetYmin() ) ) {
    p_min_idx = x_min_index;
    p_max_idx = x_max_index;
 } else {
    p_min_idx = y_min_index;
    p_max_idx = y_max_index;
  }
  
  // start fit track
  TVirtualFitter::SetDefaultFitter("Minuit");
  TVirtualFitter *min = TVirtualFitter::Fitter(0, 5);  // Fitting with theta and phi
  min -> SetObjectFit(m_gr);
  min -> SetFCN(SumDistance2);
  
  // MAKE QUIET
  double p1=-1;
  min->ExecuteCommand("SET PRINTOUT",&p1, 1);

  double arglist[6] = {-1, 0, 0, 0, 0, 0};
  /*min -> ExecuteCommand("SET PRINT", arglist, 1);
  min -> ExecuteCommand("SET NOWARNINGS", arglist, 0);
  */

  TVector3 temp_vector3 (x[p_max_idx]-x[p_min_idx],
			 y[p_max_idx]-y[p_min_idx],
			 z[p_max_idx]-z[p_min_idx]);
  double init_theta = temp_vector3.Theta();
  double init_phi   = temp_vector3.Phi();

  double pStart[5] = {x[p_min_idx], y[p_min_idx], z[p_min_idx], init_theta, init_phi};
  min -> SetParameter(0, "x0",    pStart[0], 0.01, 0, 0);
  min -> SetParameter(1, "y0",    pStart[1], 0.01, 0, 0);
  min -> SetParameter(2, "z0",    pStart[2], 0.01, 0, 0);
  min -> SetParameter(3, "theta", pStart[3], 0.0001, 0, 0);
  min -> SetParameter(4, "phi",   pStart[4], 0.0001, 0, 0);
  
  arglist[0] = 1000; // number of fucntion calls
  arglist[1] = 0.01; // tolerance
  min -> ExecuteCommand("MIGRAD", arglist, 2);
  
  double pars[5];
  double errs[5];

  for (int iPar = 0; iPar < 5; iPar++){
    pars[iPar] = min -> GetParameter(iPar);
    errs[iPar] = min -> GetParError(iPar);
  }
  
  double theta, phi;
  phi   = pars[4]*180./3.14159;
  theta = pars[3]*180./3.14159;
  
  //getTrackInfo();
  //getPID(); // Set PID flags

  /* Second arg comes from defs in constants.h */

  m_gr -> Delete();
  delete min;
}

void SumDistance2(int &, double *, double & sum, double * par, int ) {
  TGraph2D * m_gr = dynamic_cast<TGraph2D*>( (TVirtualFitter::GetFitter())->GetObjectFit() );
  //assert (m_gr != 0);
  double * px = m_gr->GetX();
  double * py = m_gr->GetY();
  double * pz = m_gr->GetZ();
  int np = m_gr->GetN();
  sum = 0;
  for (int i  = 0; i < np; ++i) {
    double d = distance2(px[i],py[i],pz[i],par);
    sum += d;
  }
}

double distance2(double px,double py,double pz, double *p) {
   TVector3 xp(px,py,pz);
   TVector3 x0(p[0], p[1], p[2]);
   TVector3 u (TMath::Sin(p[3])*TMath::Cos(p[4]), TMath::Sin(p[3])*TMath::Sin(p[4]), TMath::Cos(p[3]));

   double coeff = u*(xp-x0);
   TVector3 n = xp - x0 - coeff * u;

   double dx = n.x();
   double dy = n.y();
   double dz = n.z();
   double d2_x = TMath::Power(dx/weight[0], 2);
   double d2_y = TMath::Power(dy/weight[1], 2);
   double d2_z = TMath::Power(dz/weight[2], 2);
   double d2 = d2_x + d2_y + d2_z;

   return d2;
}

//
void skimmer::Loop(TString FileName, TString OutputName)
{
//   In a ROOT session, you can do:
//      Root > .L skimmer.C
//      Root > skimmer t
//      Root > t.GetEntry(12); // Fill t data members with entry number 12
//      Root > t.Show();       // Show values of entry 12
//      Root > t.Show(16);     // Read and show values of entry 16
//      Root > t.Loop();       // Loop on all entries
//

//     This is the loop skeleton where:
//    jentry is the global entry number in the chain
//    ientry is the entry number in the current Tree
//  Note that the argument to GetEntry must be:
//    jentry for TChain::GetEntry
//    ientry for TTree::GetEntry and TBranch::GetEntry
//
//       To read only selected branches, Insert statements like:
// METHOD1:
//    fChain->SetBranchStatus("*",0);  // disable all branches
//    fChain->SetBranchStatus("branchname",1);  // activate branchname
// METHOD2: replace line
//    fChain->GetEntry(jentry);       //read all branches
//by  b_branchname->GetEntry(ientry); //read only this branch
   //if (fChain == 0) return;

   //Long64_t nentries = fChain->GetEntriesFast();

   //Long64_t nbytes = 0, nb = 0;
   //for (Long64_t jentry=0; jentry<nentries;jentry++) {
   //   Long64_t ientry = LoadTree(jentry);
   //   if (ientry < 0) break;
   //   nb = fChain->GetEntry(jentry);   nbytes += nb;
   //   // if (Cut(ientry) < 0) continue;
   //}

   TFile df(FileName,"READ");
   // Get the TTree
   TTree *dtr = (TTree*)df.Get("tree");

   //class skimmer* event; 

   //TFile *ofile = new TFile("tpc_data.root", "RECREATE");

   TFile *ofile = new TFile(OutputName, "RECREATE");
   TTree *tr = new TTree("tr","TPC Event Data");

   //// Initialize the TTree
   Init(dtr);

   //// Activate all TBranches
   dtr->SetBranchStatus("*",1);

   //// Make TGraph for fitting the event
   TGraph2D *m_gr;
   //
   //// Make new TTree with relevant data
   int npoints, time_range, tot_sum; 
   int getentry;

   int nrows = 336;
   int ncol = 80;
   int kMaxHits = nrows * ncol;

   int row[30000];
   int col[30000];
   int tot[30000];
   int bcid[30000];

   int hitside[4];

   float par_fit[6];
   float par_fit_err[6];
   float chi2, t_length, theta, phi, sum_e;

   double tstamp;
   
   tr->Branch("npoints",&npoints,"npoints/I");
   tr->Branch("row",&row,"row[npoints]/I");
   tr->Branch("col",&col,"col[npoints]/I");
   tr->Branch("bcid",&bcid,"bcid[npoints]/I");
   tr->Branch("tot",&tot,"tot[npoints]/I");
   tr->Branch("tstamp",&tstamp,"tstamp/D");
   tr->Branch("tot_sum",&tot_sum,"tot_sum/I");
   tr->Branch("sum_e",&sum_e,"sum_e/F");
   tr->Branch("time_range",&time_range,"time_range/I");
   tr->Branch("chi2",&chi2,"chi2/F");
   tr->Branch("t_length",&t_length,"t_length/F");
   tr->Branch("theta",&theta,"theta/F");
   tr->Branch("phi",&phi,"phi/F");
   tr->Branch("par_fit",&par_fit,"par_fit[6]/F");
   tr->Branch("par_fit_err",&par_fit_err,"par_fit_err[6]/F");
   tr->Branch("hitside",&hitside,"hitside[4]/I");

   int nentries = dtr->GetEntriesFast();

   for (Long64_t jentry=0; jentry<nentries;jentry++) {

      if (jentry %10000 == 0) cout << "Event Counter: " << jentry << endl;

      Long64_t ientry = LoadTree(jentry);

      //if (ientry < 0) break;
      //nb = fChain->GetEntry(jentry);   nbytes += nb;
      // if (Cut(ientry) < 0) continue;

	  getentry = dtr->GetEntry(jentry);
	  npoints = MicrotpcMetaHits_m_pixNb[0];
	  tstamp = MicrotpcMetaHits_m_ts_start[0][0];
	  tot_sum = MicrotpcRecoTracks_m_totsum[0];
	  time_range = MicrotpcRecoTracks_m_time_range[0];
	  chi2 = MicrotpcRecoTracks_m_chi2[0];
	  t_length = MicrotpcRecoTracks_m_trl[0];
	  theta = MicrotpcRecoTracks_m_theta[0];
	  phi = MicrotpcRecoTracks_m_phi[0];
      sum_e = MicrotpcRecoTracks_m_esum[0];
	  
	  for (int nsides=0; nsides<4; nsides++){
		 hitside[nsides] = MicrotpcRecoTracks_m_side[0][nsides];
	  }

	  for (int npars=0; npars<6;npars++){
	    par_fit[npars]=MicrotpcRecoTracks_m_parFit[0][npars];
	    par_fit_err[npars]=MicrotpcRecoTracks_m_parFit_err[0][npars];
	  }

	   
	   //for (int ii=0; ii<2; ii++){
	   //tstamp = event->MicrotpcMetaHits_m_ts_start[ii][0];
	   //if (tstamp > 0){
	   //  std::cout << "Timestamp entry is " << tstamp << " in event " << jentry << " Element = " << ii << endl;
	   //  std::cin.ignore();
	   //  std::cin.get();
	   //}
	   //}
	  
	  for (int pixn=0; pixn<npoints;pixn++){
	    row[pixn]=MicrotpcDataHits_m_row[pixn];
	    col[pixn]=MicrotpcDataHits_m_column[pixn];
	    bcid[pixn]=MicrotpcDataHits_m_BCID[pixn];
	    tot[pixn]=MicrotpcDataHits_m_TOT[pixn];
	    //std::cout << "At pixel number " << pixn << std::endl;
	    //std::cout << "Column number is " << col[pixn] << std::endl;
	  }

	  //
	  //Call fitter 
	  
	  
	  tr->Fill();
//
//      /* Debug info */
//	  //if (jentry == 2) {
//	  //  cout << "Currently at event " << jentry << "\n";
//	  //  for (int i=0;i<MicrotpcDataHits_; i++){
//	  //    evt->Fill(MicrotpcDataHits_m_column[i],MicrotpcDataHits_m_row[i],MicrotpcDataHits_m_TOT[i]);
//	  //  }
//	  //}
   }
   tr->Write();
   ofile->Write();
   ofile->Close();
}


//int main()
int main(int argc, char * argv[])
{
  skimmer s;
  //s.Loop();
  //s.Loop("tpc_data_1460214023.root","test.root");
  s.Loop(argv[1], argv[2]);
  return 1;
}
